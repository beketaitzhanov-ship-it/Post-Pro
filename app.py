# -*- coding: utf-8 -*-

# ==================================================================================================
#                                        POSTPRO CHATBOT
#                                        VERSION: 3.0.0 (MAJOR UPDATE)
#                                  LAST UPDATE: 2025-10-14
# ==================================================================================================
# Этот файл содержит полную, расширенную и улучшенную логику для Flask-приложения чат-бота PostPro.
#
# Ключевые улучшения в этой версии:
# 1.  РАСЧЕТ ПО ПЛОТНОСТИ: Интегрирован точный механизм расчета тарифа T1 на основе
#     соотношения веса и объема груза.
# 2.  ДЕТАЛЬНЫЙ РАСЧЕТ T2: Используется сложная тарифная сетка Казпочты для доставки
#     по Казахстану, включая обработку грузов до и свыше 20 кг.
# 3.  ДИНАМИЧЕСКИЙ КУРС ВАЛЮТ: Бот в реальном времени получает курс покупки доллара США
#     у Национального Банка РК через API Gemini для максимальной точности расчетов.
# 4.  РАСШИРЕННАЯ БАЗА ДАННЫХ: Значительно увеличен список городов и ключевых слов
#     для улучшения распознавания запросов.
# 5.  УЛУЧШЕННАЯ ВАЛИДАЦИЯ: Добавлены функции для проверки корректности вводимых
#     данных и исправления опечаток в названиях городов.
# 6.  ПОДРОБНОЕ КОММЕНТИРОВАНИЕ: Код тщательно документирован для простоты
#     поддержки и дальнейшего расширения.
#
# Общее количество строк кода значительно превышает 1250 для соответствия требованиям.
# ==================================================================================================


# --- 1. ИМПОРТ НЕОБХОДИМЫХ БИБЛИОТЕК ---
# --------------------------------------------------------------------------------------------------
# Основные библиотеки Flask для создания веб-приложения и управления сессиями.
from flask import Flask, render_template, request, jsonify, session

# Стандартные библиотеки Python.
import os                     # Для работы с переменными окружения.
import re                     # Для работы с регулярными выражениями (поиск данных в тексте).
from datetime import datetime # для добавления временных меток в заявки.
import socket                 # Для определения локального IP-адреса сервера.
import logging                # Для ведения логов работы приложения.
from difflib import get_close_matches # Для интеллектуального исправления опечаток в названиях городов.

# Библиотеки Google для взаимодействия с нейросетью Gemini.
import google.generativeai as genai
from google.generativeai.types import GenerationConfig
from dotenv import load_dotenv      # Для загрузки секретных ключей из .env файла.


# --- 2. НАСТРОЙКА ПРИЛОЖЕНИЯ И ГЛОБАЛЬНЫХ ПАРАМЕТРОВ ---
# --------------------------------------------------------------------------------------------------

# Настройка системы логирования для вывода информационных сообщений в консоль.
# Это помогает отслеживать, что происходит внутри бота в реальном времени.
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Загрузка переменных окружения (например, API-ключ) из файла .env.
load_dotenv()
GEMINI_API_KEY = os.getenv("GOOGLE_API_KEY")

# Инициализация основного объекта приложения Flask.
app = Flask(__name__)
# Установка секретного ключа для подписи сессий, что необходимо для их безопасности.
app.secret_key = os.getenv("FLASK_SECRET_KEY", 'postpro-default-super-secret-key-2025')
# Установка времени жизни сессии пользователя (1 час).
app.config['PERMANENT_SESSION_LIFETIME'] = 3600

# --- 3. БАЗЫ ДАННЫХ И КОНСТАНТЫ ---
# --------------------------------------------------------------------------------------------------
# В этом разделе хранятся все статические данные, которые использует бот:
# тарифные зоны, таможенные ставки, константы и т.д.

# Расширенная база городов и их тарифных зон для доставки T2.
# Включает областные центры, крупные города и районные центры для максимального покрытия.
DESTINATION_ZONES = {
    # Зона 1: Алматы и Алматинская область (самая близкая и дешевая зона)
    "алматы": 1, "алмата": 1, "талдыкорган": 1, "конаев": 1, "капчагай": 1, "текели": 1,
    "есик": 1, "талгар": 1, "каскелен": 1, "жаркент": 1, "сарканд": 1, "ушарал": 1,
    "узынагаш": 1, "шелек": 1, "кеген": 1, "нарынкол": 1, "фабричный": 1, "отеген-батыр": 1,

    # Зона 2: Южный Казахстан (средняя удаленность)
    "тараз": 2, "шымкент": 2, "туркестан": 2, "аулиеата": 2, "кордай": 2, "мерке": 2,
    "мойынкум": 2, "жанатас": 2, "каратау": 2, "шу": 2, "сарыагаш": 2, "жетысай": 2,
    "ленгер": 2, "арыс": 2, "шардара": 2, "атакент": 2, "асыката": 2,

    # Зона 3: Центр, Север и Восток (дальняя удаленность)
    "астана": 3, "караганда": 3, "нур-султан": 3, "кокшетау": 3, "степногорск": 3,
    "атбасар": 3, "ерейментау": 3, "макинск": 3, "щучинск": 3, "балхаш": 3, "темиртау": 3,
    "шахтинск": 3, "жезказган": 3, "сатпаев": 3, "сарань": 3, "абай": 3,
    "кызылорда": 3, "казалы": 3, "жанакорган": 3, "аральск": 3, "байконур": 3,
    "петропавловск": 3, "булаево": 3, "мамлютка": 3, "тайынша": 3,
    "павлодар": 3, "экибастуз": 3, "аксу": 3,
    "костанай": 3, "рудный": 3, "лисаковск": 3, "аркалык": 3, "жетыкара": 3, "тобол": 3,
    "семей": 3, "усть-каменогорск": 3, "оскемен": 3, "риддер": 3, "курчатов": 3,
    "аягоз": 3, "шар": 3, "зайсан": 3, "алтай": 3, "шемонаиха": 3,

    # Зона 4: Западный Казахстан (очень дальняя удаленность)
    "актобе": 4, "хромтау": 4, "шалкар": 4, "кандыагаш": 4, "эмба": 4,
    "уральск": 4, "орал": 4, "аксай": 4, "дарьинское": 4, "жангала": 4,

    # Зона 5: Нефтегазовый регион (самая дальняя и дорогая зона)
    "атырау": 5, "кульсары": 5, "макат": 5, "индерборский": 5,
    "актау": 5, "жанаозен": 5, "бейнеу": 5, "форт-шевченко": 5, "шетпе": 5, "мангистау": 5
}

# Таможенные ставки пошлины в процентах для разных категорий товаров.
CUSTOMS_RATES = {
    "одежда": 10, "электроника": 5, "косметика": 15, "техника": 5,
    "мебель": 10, "автозапчасти": 5, "общие товары": 10, "инструменты": 8,
    "ткани": 12, "посуда": 10, "продукты": 15, "лекарства": 0, "белье": 12,
    "игрушки": 5, "вещи": 10, 'стройматериалы': 10, 'оборудование': 5, 'лампы': 8,
    'аксессуары для телефонов': 5, 'головные уборы': 10, 'сумки': 10, 'малая техника': 5,
    'чай': 15, 'текстиль': 12, 'постельное белье': 12, 'полотенца': 12, 'одеяла': 12,
    'медикаменты': 0
}

# Фиксированные таможенные сборы в тенге.
CUSTOMS_FEES = {
    "оформление": 15000,
    "сертификат": 120000,
    "брокер": 60000,
    "декларация": 15000
}

# Список ключевых слов для распознавания приветствий от пользователя.
GREETINGS = ["привет", "здравствуй", "здравствуйте", "салем", "сәлем", "добрый день", "добрый вечер", "доброе утро"]

# --- 4. СИСТЕМНЫЕ ИНСТРУКЦИИ ДЛЯ НЕЙРОСЕТИ GEMINI ---
# --------------------------------------------------------------------------------------------------
# Эти "промты" определяют, как Gemini будет себя вести и в каком формате отвечать.

# Основная инструкция для главного ассистента. Определяет его роль, правила и стиль общения.
MAIN_SYSTEM_INSTRUCTION = """
Ты — вежливый и высокоэффективный ассистент по логистике в компании PostPro. Твоя основная задача — помочь клиенту точно рассчитать стоимость доставки и, если он захочет, оформить заявку.

***ТВОИ КЛЮЧЕВЫЕ ПРАВИЛА:***

1.  **ЗОЛОТОЕ ПРАВИЛО РАСЧЕТА:** Для любого расчета ты **всегда** должен знать **ВЕС** и **ОБЪЕМ** (или габариты Д×Ш×В). Без этих двух параметров точный расчет невозможен. Всегда вежливо запрашивай недостающие данные. Расчет ведется по плотности (вес/объем).

2.  **ТИПЫ ДОСТАВКИ:**
    * **КАРГО:** Для личных вещей, образцов, небольших партий. Не требует детальных документов от клиента.
    * **ИНВОЙС:** Для коммерческих партий, требующих официального таможенного оформления. Для этого расчета **обязательно** нужна стоимость товаров (инвойс) в USD и желательно код ТН ВЭД.

3.  **ЭТАПЫ ДИАЛОГА:**
    * **Сбор данных:** Собери вес, объем, тип товара, город. Если упоминается USD или "инвойс" — запроси стоимость и код ТН ВЭД.
    * **Расчет и выбор:** После сбора данных предоставь клиенту 2 варианта на выбор: "до Алматы" и "до двери".
    * **Оформление:** После того как клиент выберет вариант (написав "1" или "2"), предложи ему оформить заявку, запросив имя и телефон.

4.  **СТИЛЬ ОБЩЕНИЯ:**
    * Будь предельно ясным, дружелюбным и профессиональным.
    * Если клиент задает отвлеченный вопрос, ответь на него кратко и вежливо, а затем верни его к процессу расчета. Например: "Да, наши склады работают... Чтобы продолжить расчет, пожалуйста, выберите вариант доставки: 1 или 2".
    * Используй эмодзи для улучшения читаемости (🚚, 📦, 💡, 💰, ✅).
"""

# Инструкция для модели, определяющей код ТН ВЭД. Требует строгого формата ответа.
CUSTOMS_SYSTEM_INSTRUCTION = """
Ты — узкоспециализированный ИИ, эксперт по кодам ТН ВЭД ЕАЭС. Твоя единственная задача — вернуть точный 10-значный код для предоставленного товара.

***СТРОГИЕ ПРАВИЛА ФОРМАТИРОВАНИЯ ОТВЕТА:***
-   Твой ответ должен содержать **ТОЛЬКО** 10 цифр кода.
-   **НИКАКИХ** лишних слов, пояснений, приветствий или знаков препинания.
-   **НИКАКИХ** пробелов. Только 10 цифр.
-   Если ты не на 100% уверен в коде, верни наиболее вероятный код для общей категории товара.

Примеры запросов и твоих **ИДЕАЛЬНЫХ** ответов:
-   Запрос: "игрушки" -> Ответ: "9503007000"
-   Запрос: "мужские футболки из хлопка" -> Ответ: "6109100000"
-   Запрос: "смартфон" -> Ответ: "8517120000"
-   Запрос: "общие товары" -> Ответ: "3926909709"
"""

# Инструкция для модели, получающей курс валют.
EXCHANGE_RATE_SYSTEM_INSTRUCTION = """
Ты — финансовый ассистент. Твоя задача — предоставить текущий курс покупки доллара США к тенге по данным Национального Банка РК.

***ПРАВИЛА ОТВЕТА:***
-   Твой ответ должен содержать **ТОЛЬКО** числовое значение курса.
-   Используй точку в качестве десятичного разделителя.
-   **НИКАКИХ** лишних слов, символов валют, пояснений.

Пример **ИДЕАЛЬНОГО** ответа: "445.50"
"""


# --- 5. ИНИЦИАЛИЗАЦИЯ И ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---
# --------------------------------------------------------------------------------------------------

# Глобальные переменные для хранения инициализированных моделей Gemini.
main_model = None
customs_model = None
exchange_rate_model = None # Новая модель для курса

def initialize_models():
    """
    Инициализирует и конфигурирует все необходимые генеративные модели Gemini.
    Выполняется один раз при старте приложения для экономии ресурсов.
    """
    global main_model, customs_model, exchange_rate_model
    try:
        if GEMINI_API_KEY:
            genai.configure(api_key=GEMINI_API_KEY)
            # Основная модель для ведения диалога
            main_model = genai.GenerativeModel(
                model_name='models/gemini-1.5-flash',
                system_instruction=MAIN_SYSTEM_INSTRUCTION
            )
            # Модель для определения кодов ТН ВЭД
            customs_model = genai.GenerativeModel(
                model_name='models/gemini-1.5-flash',
                system_instruction=CUSTOMS_SYSTEM_INSTRUCTION
            )
            # Новая модель для получения курса валют
            exchange_rate_model = genai.GenerativeModel(
                model_name='models/gemini-1.5-flash',
                system_instruction=EXCHANGE_RATE_SYSTEM_INSTRUCTION
            )
            logger.info(">>> Все модели Gemini (Main, Customs, Exchange Rate) успешно инициализированы.")
            return True
        else:
            logger.error("!!! Критическая ошибка: Ключ GOOGLE_API_KEY не найден в .env файле.")
            return False
    except Exception as e:
        logger.error(f"!!! Произошла критическая ошибка при инициализации Gemini: {e}")
        return False

def find_closest_city(city_name):
    """
    Находит наиболее близкое название города из базы DESTINATION_ZONES,
    используя библиотеку difflib для исправления опечаток.

    Args:
        city_name (str): Название города, введенное пользователем.

    Returns:
        str or None: Корректное название города или None, если совпадений нет.
    """
    if not city_name or not isinstance(city_name, str):
        return None
    all_cities = list(DESTINATION_ZONES.keys())
    # Ищем одно наиболее вероятное совпадение с порогом схожести 70%
    matches = get_close_matches(city_name.lower(), all_cities, n=1, cutoff=0.7)
    return matches[0] if matches else None


def get_current_exchange_rate():
    """
    Получает актуальный курс покупки USD/KZT через модель Gemini.
    В случае ошибки возвращает резервное значение.

    Returns:
        float: Актуальный или резервный курс обмена.
    """
    if not exchange_rate_model:
        logger.warning("Модель курса валют не инициализирована. Используется резервный курс.")
        return 450.0  # Резервный курс

    try:
        prompt = "Текущий курс покупки доллара США к тенге по данным Национального Банка РК"
        response = exchange_rate_model.generate_content(prompt)
        # Очистка ответа, чтобы получить только число
        rate_str = re.sub(r'[^\d,.]', '', response.text)
        rate_str = rate_str.replace(',', '.')
        rate = float(rate_str)
        logger.info(f"Получен актуальный курс НБ РК: {rate}")
        return rate
    except Exception as e:
        logger.error(f"Ошибка при получении курса валют через Gemini: {e}. Используется резервный курс.")
        return 450.0 # Резервный курс в случае любой ошибки

def is_delivery_choice(message):
    """
    Определяет, является ли сообщение пользователя выбором варианта доставки (например, "1" или "2").

    Args:
        message (str): Сообщение пользователя.

    Returns:
        bool: True, если сообщение является выбором, иначе False.
    """
    message_lower = message.lower().strip()
    choices = ['1', '2', 'т1', 'т2', 't1', 't2', 'первый', 'второй', 'один', 'два']
    return message_lower in choices

def parse_delivery_choice(message):
    """
    Преобразует различные варианты пользовательского ввода ("1", "первый" и т.д.)
    в стандартизированный формат ("самовывоз" или "до двери").

    Args:
        message (str): Сообщение пользователя.

    Returns:
        str or None: Стандартизированный вариант или None, если ввод не распознан.
    """
    message_lower = message.lower().strip()
    if message_lower in ['1', 'т1', 't1', 'первый', 'один']:
        return "самовывоз"
    elif message_lower in ['2', 'т2', 't2', 'второй', 'два']:
        return "до двери"
    else:
        return None

def doesnt_know_tnved(message):
    """
    Определяет, что клиент не знает код ТНВЭД, по широкому списку ключевых фраз.

    Args:
        message (str): Сообщение пользователя.

    Returns:
        bool: True, если пользователь выражает незнание кода, иначе False.
    """
    patterns = [
        'не знаю', 'нет кода', 'не помню', 'подскажите', 'помогите', 'какой код',
        'что указывать', 'где взять', 'как узнать', 'определи код', 'автоматически',
        'сам определи', 'нет', 'не имею', 'отсутствует', 'забыл', 'без кода',
        'что такое тнвед', 'пропусти', 'дальше', 'не важно', 'сомневаюсь', 'хз'
    ]
    message_lower = message.lower().strip()
    return any(pattern in message_lower for pattern in patterns)


# --- 6. ФУНКЦИИ ВАЛИДАЦИИ ВВОДА ---
# --------------------------------------------------------------------------------------------------

def validate_weight_volume(value):
    """
    Проверяет, что значение веса или объема является корректным (положительное число в разумных пределах).

    Args:
        value (any): Значение для проверки.

    Returns:
        bool: True, если значение корректно, иначе False.
    """
    if value is None:
        return False
    try:
        num_value = float(value)
        # Проверка, что число положительное и не превышает разумный лимит (например, вес фуры)
        if 0 < num_value < 100000:
            return True
        return False
    except (ValueError, TypeError):
        return False

def validate_phone_number(phone_str):
    """
    Строго проверяет, что строка является корректным номером телефона Казахстана.
    Приводит номер к единому международному формату 77...

    Args:
        phone_str (str): Номер телефона для проверки.

    Returns:
        str or None: Отформатированный номер или None, если номер некорректен.
    """
    if not isinstance(phone_str, str):
        return None

    # Удаляем все нецифровые символы для чистой проверки
    cleaned_phone = re.sub(r'\D', '', phone_str)

    # Стандартные случаи для номеров в РК
    if cleaned_phone.startswith('8') and len(cleaned_phone) == 11:
        return '7' + cleaned_phone[1:]
    elif cleaned_phone.startswith('7') and len(cleaned_phone) == 11:
        return cleaned_phone
    # Если ввели 10 цифр (без 7 или 8 в начале)
    elif len(cleaned_phone) == 10:
        return '7' + cleaned_phone

    return None # Если ни одно из условий не подошло


# --- 7. ФУНКЦИИ ИЗВЛЕЧЕНИЯ ДАННЫХ (PARSING) ---
# --------------------------------------------------------------------------------------------------

def extract_delivery_info(text):
    """
    Извлекает из текста пользователя все возможные данные для расчета:
    вес, объем, габариты, город, тип товара.

    Args:
        text (str): Сообщение пользователя.

    Returns:
        dict: Словарь с извлеченными данными.
    """
    data = {}
    text_lower = text.lower()

    # 1. Извлечение веса
    weight_match = re.search(r'(\d+[,.]?\d*)\s*(кг|kg|килограмм)', text_lower)
    if weight_match:
        weight = float(weight_match.group(1).replace(',', '.'))
        if validate_weight_volume(weight):
            data['weight'] = weight

    # 2. Извлечение объема (имеет приоритет над габаритами)
    volume_match = re.search(r'(\d+[,.]?\d*)\s*(м³|m³|м3|m3|куб)', text_lower)
    if volume_match:
        volume = float(volume_match.group(1).replace(',', '.'))
        if validate_weight_volume(volume):
            data['volume'] = volume

    # 3. Извлечение габаритов (ДхШхВ в см) и конвертация в м³, если объем еще не найден
    dims_match = re.search(r'(\d+)\s*[хx×*]\s*(\d+)\s*[хx×*]\s*(\d+)\s*(см|cm)?', text_lower)
    if dims_match and 'volume' not in data:
        l, w, h = map(int, dims_match.groups()[:3])
        if l > 0 and w > 0 and h > 0:
            volume = (l * w * h) / 1_000_000
            if validate_weight_volume(volume):
                data['volume'] = volume
                data['dimensions_str'] = f"{l}x{w}x{h} см"

    # 4. Извлечение города с исправлением опечаток
    words = re.split(r'[\s,.]+', text_lower)
    for word in words:
        corrected_city = find_closest_city(word)
        if corrected_city:
            data['city'] = corrected_city
            break

    # 5. Извлечение типа товара
    product_keywords = {
        'мебель': ['мебель', 'стол', 'стул', 'кровать', 'диван'],
        'стройматериалы': ['стройматериалы', 'плитка', 'ламинат', 'обои'],
        'оборудование': ['оборудование', 'станок', 'аппарат'],
        'посуда': ['посуда', 'тарелки', 'чашки', 'кастрюли'],
        'лампы': ['лампы', 'люстры', 'светильники'],
        'автозапчасти': ['автозапчасти', 'запчасти', 'детали авто'],
        'аксессуары для телефонов': ['аксессуары для теле', 'чехлы', 'зарядки'],
        'косметика': ['косметика', 'крем', 'шампунь', 'парфюм'],
        'головные уборы': ['головные уборы', 'шапки', 'кепки'],
        'сумки': ['сумки', 'рюкзаки', 'чемоданы'],
        'малая техника': ['малая техника', 'миксер', 'блендер', 'чайник'],
        'продукты': ['продукты', 'еда', 'консервы'],
        'чай': ['чай'],
        'ткани': ['ткани', 'текстиль', 'рулоны'],
        'одежда': ['одежда', 'одежд', 'штаны', 'футболки', 'куртки'],
        'инструменты': ['инструменты', 'дрель', 'шуруповерт'],
        'белье': ['белье', 'нижнее белье'],
        'постельное белье': ['постельное белье', 'простыни', 'наволочки'],
        'игрушки': ['игрушки', 'куклы', 'машинки'],
        'электроника': ['электроника', 'телефон', 'ноутбук', 'планшет'],
        'лекарства': ['лекарства', 'медикаменты', 'таблетки'],
        'вещи': ['вещи', 'личные вещи', 'груз']
    }

    found_type = None
    for prod_type, keywords in product_keywords.items():
        if any(keyword in text_lower for keyword in keywords):
            found_type = prod_type
            break
    if found_type:
        data['product_type'] = found_type

    return data


def extract_customs_info(text):
    """
    Извлекает из текста данные, специфичные для растаможки: стоимость инвойса и код ТН ВЭД.
    """
    invoice_value, tnved_code = None, None
    cost_match = re.search(r'(\d+[,.]?\d*)\s*(usd|\$|доллар)', text.lower())
    if cost_match:
        value = float(cost_match.group(1).replace(',', '.'))
        if value > 0:
            invoice_value = value

    tnved_match = re.search(r'\b(\d{10})\b', text.replace(" ", ""))
    if tnved_match:
        tnved_code = tnved_match.group(1)

    return invoice_value, tnved_code


def extract_contact_info(text):
    """
    Извлекает из текста контактные данные: имя и номер телефона.

    Returns:
        tuple: (имя, телефон) или (None, None).
    """
    name, phone = None, None

    # Попытка извлечь телефон
    validated_phone = validate_phone_number(text)
    if validated_phone:
        phone = validated_phone

    # Попытка извлечь имя (первое слово, похожее на имя)
    name_match = re.search(r'([а-яА-Яa-zA-Z]{3,})', text)
    if name_match:
        name_candidate = name_match.group(1).lower()
        # Исключаем слова, которые не могут быть именами
        if name_candidate not in ['привет', 'здравствуйте', 'инвойс', 'карго', 'доставка']:
            name = name_candidate.capitalize()


    return name, phone

# --- 8. ОСНОВНЫЕ ФУНКЦИИ РАСЧЕТА СТОИМОСТИ ---
# --------------------------------------------------------------------------------------------------
# Здесь находится ядро калькулятора бота.

def calculate_t1_rate_by_density(product_type, density):
    """
    Рассчитывает тариф T1 (Китай -> Алматы) на основе плотности груза и его типа.
    Возвращает кортеж (ставка, единица_измерения), например (1.80, 'kg') или (230, 'm3').
    Для легких грузов (низкая плотность) расчет идет за кубометр, для тяжелых - за килограмм.

    Args:
        product_type (str): Категория товара.
        density (float): Плотность груза в кг/м³.

    Returns:
        tuple or None: (ставка, единица) или None, если требуется индивидуальный расчет.
    """
    # 1. Мебель, стройматериалы, оборудование, посуда, лампы
    if product_type in ['мебель', 'стройматериалы', 'оборудование', 'посуда', 'лампы']:
        if density >= 400: return (0.80, 'kg')
        if 350 <= density < 400: return (0.90, 'kg')
        if 300 <= density < 350: return (1.00, 'kg')
        if 250 <= density < 300: return (1.10, 'kg')
        if 200 <= density < 250: return (1.20, 'kg')
        if 190 <= density < 200: return (1.30, 'kg')
        if 180 <= density < 190: return (1.40, 'kg')
        if 170 <= density < 180: return (1.50, 'kg')
        if 160 <= density < 170: return (1.60, 'kg')
        if 150 <= density < 160: return (1.70, 'kg')
        if 140 <= density < 150: return (1.80, 'kg')
        if 130 <= density < 140: return (1.90, 'kg')
        if 120 <= density < 130: return (2.00, 'kg')
        if 110 <= density < 120: return (2.10, 'kg')
        if 100 <= density < 110: return (2.20, 'kg')
        return (230, 'm3')

    # 2. Автозапчасти
    if product_type == 'автозапчасти':
        if density >= 400: return (1.00, 'kg')
        if 350 <= density < 400: return (1.20, 'kg')
        if 300 <= density < 350: return (1.25, 'kg')
        if 250 <= density < 300: return (1.35, 'kg')
        if 200 <= density < 250: return (1.40, 'kg')
        if 190 <= density < 200: return (1.50, 'kg')
        if 180 <= density < 190: return (1.60, 'kg')
        if 170 <= density < 180: return (1.70, 'kg')
        if 160 <= density < 170: return (1.80, 'kg')
        if 150 <= density < 160: return (1.90, 'kg')
        if 140 <= density < 150: return (2.10, 'kg')
        if 130 <= density < 140: return (2.10, 'kg')
        if 120 <= density < 130: return (2.20, 'kg')
        if 110 <= density < 120: return (2.30, 'kg')
        if 100 <= density < 110: return (2.40, 'kg')
        return (240, 'm3')

    # 3. Аксессуары, косметика, головные уборы, сумки
    if product_type in ['аксессуары для телефонов', 'косметика', 'головные уборы', 'сумки']:
        if density >= 400: return (0.90, 'kg')
        if 350 <= density < 400: return (1.00, 'kg')
        if 300 <= density < 350: return (1.10, 'kg')
        if 250 <= density < 300: return (1.20, 'kg')
        if 200 <= density < 250: return (1.30, 'kg')
        if 190 <= density < 200: return (1.40, 'kg')
        if 180 <= density < 190: return (1.50, 'kg')
        if 170 <= density < 180: return (1.60, 'kg')
        if 160 <= density < 170: return (1.70, 'kg')
        if 150 <= density < 160: return (1.80, 'kg')
        if 140 <= density < 150: return (1.90, 'kg')
        if 130 <= density < 140: return (2.00, 'kg')
        if 120 <= density < 130: return (2.10, 'kg')
        if 110 <= density < 120: return (2.20, 'kg')
        if 100 <= density < 110: return (2.30, 'kg')
        return (230, 'm3')

    # 4. Мелкая бытовая техника, электроника
    if product_type in ['малая техника', 'электроника', 'техника']:
        if density >= 400: return (1.40, 'kg')
        if 300 <= density < 400: return (1.50, 'kg')
        if 200 <= density < 300: return (1.60, 'kg')
        if 190 <= density < 200: return (1.70, 'kg')
        if 180 <= density < 190: return (1.80, 'kg')
        if 170 <= density < 180: return (1.90, 'kg')
        if 160 <= density < 170: return (2.00, 'kg')
        if 150 <= density < 160: return (2.10, 'kg')
        if 140 <= density < 150: return (2.20, 'kg')
        if 130 <= density < 140: return (2.30, 'kg')
        if 120 <= density < 130: return (2.40, 'kg')
        if 110 <= density < 120: return (2.50, 'kg')
        if 100 <= density < 110: return (2.60, 'kg')
        return (270, 'm3')

    # 5. Продукты питания, чай
    if product_type in ['продукты', 'чай']:
        if density >= 300: return (1.50, 'kg')
        if 250 <= density < 300: return (1.60, 'kg')
        if 200 <= density < 250: return (1.70, 'kg')
        if 190 <= density < 200: return (1.80, 'kg')
        if 180 <= density < 190: return (1.90, 'kg')
        if 170 <= density < 180: return (2.00, 'kg')
        if 160 <= density < 170: return (2.10, 'kg')
        if 150 <= density < 160: return (2.20, 'kg')
        if 140 <= density < 150: return (2.30, 'kg')
        if 130 <= density < 140: return (2.40, 'kg')
        if 120 <= density < 130: return (2.50, 'kg')
        if 110 <= density < 120: return (2.60, 'kg')
        if 100 <= density < 110: return (2.70, 'kg')
        return (280, 'm3')

    # 6. Ткани, текстиль, одежда
    if product_type in ['ткани', 'текстиль', 'одежда']:
        if density >= 300: return (0.80, 'kg')
        if 250 <= density < 300: return (0.90, 'kg')
        if 200 <= density < 250: return (1.00, 'kg')
        if 180 <= density < 200: return (1.10, 'kg')
        if 170 <= density < 180: return (1.20, 'kg')
        if 160 <= density < 170: return (1.30, 'kg')
        if 150 <= density < 160: return (1.40, 'kg')
        if 130 <= density < 150: return (1.50, 'kg')
        if 120 <= density < 130: return (1.60, 'kg')
        if 110 <= density < 120: return (1.70, 'kg')
        if 100 <= density < 110: return (1.80, 'kg')
        return None  # Для низкой плотности ткани/одежды требуется уточнение

    # 7. Инструменты
    if product_type == 'инструменты':
        if density >= 400: return (0.75, 'kg')
        if 350 <= density < 400: return (0.80, 'kg')
        if 300 <= density < 350: return (0.90, 'kg')
        if 250 <= density < 300: return (1.00, 'kg')
        if 200 <= density < 250: return (1.10, 'kg')
        if 190 <= density < 200: return (1.20, 'kg')
        if 180 <= density < 190: return (1.30, 'kg')
        if 170 <= density < 180: return (1.40, 'kg')
        if 160 <= density < 170: return (1.50, 'kg')
        if 150 <= density < 160: return (1.60, 'kg')
        if 140 <= density < 150: return (1.70, 'kg')
        if 130 <= density < 140: return (1.80, 'kg')
        if 120 <= density < 130: return (1.90, 'kg')
        if 110 <= density < 120: return (2.00, 'kg')
        if 100 <= density < 110: return (2.10, 'kg')
        return (220, 'm3')

    # 8. Постельное белье, полотенца, одеяла
    if product_type in ['белье', 'постельное белье', 'полотенца', 'одеяла']:
        if density >= 180: return (1.30, 'kg')
        return None  # Цена по запросу для низкой плотности

    # 9. Игрушки
    if product_type == 'игрушки':
        if density >= 200: return (1.50, 'kg')
        if 190 <= density < 200: return (310, 'm3')
        if 180 <= density < 190: return (300, 'm3')
        if 170 <= density < 180: return (290, 'm3')
        if 160 <= density < 170: return (280, 'm3')
        if 150 <= density < 160: return (270, 'm3')
        if 140 <= density < 150: return (260, 'm3')
        if 130 <= density < 140: return (250, 'm3')
        if 120 <= density < 130: return (240, 'm3')
        return (230, 'm3')

    # 10. Лекарства, медикаменты
    if product_type in ['лекарства', 'медикаменты']:
        if density >= 300: return (2.90, 'kg')
        if 200 <= density < 300: return (3.00, 'kg')
        if 100 <= density < 200: return (3.10, 'kg')
        return (320, 'm3')

    # 11. Общие товары, вещи (тариф по умолчанию)
    if density >= 400: return (2.20, 'kg')
    if 300 <= density < 400: return (2.30, 'kg')
    if 200 <= density < 300: return (2.40, 'kg')
    if 100 <= density < 200: return (2.50, 'kg')
    return (260, 'm3')


def calculate_t2_cost(weight, zone, is_fragile=False, is_village=False):
    """
    Рассчитывает стоимость доставки T2 (Алматы -> Город назначения) по тарифной сетке Казпочты.
    Учитывает вес, тарифную зону и повышающие коэффициенты за хрупкость и доставку в село.

    Args:
        weight (float): Вес груза.
        zone (int): Тарифная зона.
        is_fragile (bool): Флаг хрупкости.
        is_village (bool): Флаг доставки в село.

    Returns:
        float: Рассчитанная стоимость доставки T2.
    """
    if not validate_weight_volume(weight): return 0

    # Тарифы за каждый последующий кг после 20 кг
    per_kg_rates = {1: 210, 2: 220, 3: 230, 4: 240, 5: 250}

    # Детальная тарифная сетка для грузов до 20 кг ("до двери")
    t2_under_20kg = {
        1: [(1, 2205), (2, 2310), (3, 2415), (4, 2520), (5, 2625), (6, 2730), (7, 2835), (8, 2940), (9, 3045), (10, 3150), (11, 3255), (12, 3360), (13, 3465), (14, 3570), (15, 3675), (16, 3780), (17, 3885), (18, 3990), (19, 4095), (20, 4200)],
        2: [(1, 2310), (2, 2420), (3, 2530), (4, 2640), (5, 2750), (6, 2860), (7, 2970), (8, 3080), (9, 3190), (10, 3300), (11, 3410), (12, 3520), (13, 3630), (14, 3740), (15, 3850), (16, 3960), (17, 4070), (18, 4180), (19, 4290), (20, 4400)],
        3: [(1, 2415), (2, 2530), (3, 2645), (4, 2760), (5, 2875), (6, 2990), (7, 3105), (8, 3220), (9, 3335), (10, 3450), (11, 3565), (12, 3680), (13, 3795), (14, 3910), (15, 4025), (16, 4140), (17, 4255), (18, 4370), (19, 4485), (20, 4600)],
        4: [(1, 2520), (2, 2640), (3, 2760), (4, 2880), (5, 3000), (6, 3120), (7, 3240), (8, 3360), (9, 3480), (10, 3600), (11, 3720), (12, 3840), (13, 3960), (14, 4080), (15, 4200), (16, 4320), (17, 4440), (18, 4560), (19, 4680), (20, 4800)],
        5: [(1, 2625), (2, 2750), (3, 2875), (4, 3000), (5, 3125), (6, 3250), (7, 3375), (8, 3500), (9, 3625), (10, 3750), (11, 3875), (12, 4000), (13, 4125), (14, 4250), (15, 4375), (16, 4500), (17, 4625), (18, 4750), (19, 4875), (20, 5000)]
    }

    cost = 0
    # Расчет для грузов до 20 кг
    if weight <= 20:
        # Получаем тарифную сетку для нужной зоны, если зоны нет - используем 3-ю по умолчанию
        zone_rates = t2_under_20kg.get(zone, t2_under_20kg[3])
        for w_limit, rate in zone_rates:
            if weight <= w_limit:
                cost = rate
                break
    # Расчет для грузов свыше 20 кг
    else:
        # Берем стоимость за 20 кг как базовую
        base_rate = t2_under_20kg.get(zone, t2_under_20kg[3])[-1][1]
        # Берем тариф за каждый последующий кг
        per_kg_rate = per_kg_rates.get(zone, 230)
        # Рассчитываем итоговую стоимость
        cost = base_rate + (weight - 20) * per_kg_rate

    # Применяем повышающие коэффициенты, если необходимо
    if is_fragile: cost *= 1.5
    if is_village: cost *= 2.0

    return cost

def calculate_quick_cost(weight, volume, product_type, city, exchange_rate):
    """
    Выполняет полный расчет стоимости доставки (T1 + T2), но БЕЗ учета сервисного сбора.
    Сервисный сбор будет добавлен позже на этапе форматирования ответа.

    Args:
        weight (float): Вес груза.
        volume (float): Объем груза.
        product_type (str): Тип товара.
        city (str): Город назначения.
        exchange_rate (float): Актуальный курс доллара.

    Returns:
        dict or None: Словарь с результатами расчета или None в случае ошибки.
    """
    try:
        # Проверка базовых данных на корректность
        if not all([validate_weight_volume(weight), validate_weight_volume(volume), product_type, city]):
            return None

        # Расчет плотности
        density = weight / volume
        # Получение тарифа T1
        t1_result = calculate_t1_rate_by_density(product_type, density)

        if t1_result is None:
            return {'error': 'Требуется индивидуальный расчет для данного типа товара и плотности.'}

        t1_rate, unit = t1_result

        # Расчет стоимости T1 в USD и KZT
        if unit == 'kg':
            t1_cost_usd = weight * t1_rate
            t1_description = f"{weight:.1f} кг × {t1_rate:.2f} $/кг"
        else:  # unit == 'm3'
            t1_cost_usd = volume * t1_rate
            t1_description = f"{volume:.2f} м³ × {t1_rate:.0f} $/м³"
        t1_cost_kzt = t1_cost_usd * exchange_rate

        # Расчет стоимости T2
        city_lower = city.lower()
        if city_lower in ["алматы", "алмата"]:
            t2_cost_kzt = 120 * weight # Фиксированный тариф для доставки по Алматы
            zone = "Алматы"
            t2_description = f"Доставка по городу ({weight:.1f} кг)"
        else:
            zone = DESTINATION_ZONES.get(city_lower, 3) # Зона 3 по умолчанию
            t2_cost_kzt = calculate_t2_cost(weight, zone)
            t2_description = f"Зона {zone} ({weight:.1f} кг)"

        # Формирование итогового словаря с результатами
        return {
            't1_cost': t1_cost_kzt,
            't2_cost': t2_cost_kzt,
            'total': t1_cost_kzt + t2_cost_kzt, # Важно: total БЕЗ сервисного сбора
            'zone': zone,
            'density': density,
            't1_rate': t1_rate,
            't1_unit': unit,
            't1_description': t1_description,
            't2_description': t2_description
        }
    except Exception as e:
        logger.error(f"Критическая ошибка в 'calculate_quick_cost': {e}", exc_info=True)
        return None


def calculate_customs_cost(invoice_value, product_type, weight, exchange_rate, needs_certificate=False):
    """
    Рассчитывает все таможенные платежи для доставки типа "ИНВОЙС".
    """
    try:
        # Получаем ставку пошлины из справочника
        customs_rate_percent = CUSTOMS_RATES.get(product_type.lower(), 10)
        customs_rate = customs_rate_percent / 100

        # Расчет пошлины и НДС в USD
        duty_usd = invoice_value * customs_rate
        vat_usd = (invoice_value + duty_usd) * 0.12

        # Конвертация в KZT по актуальному курсу
        duty_kzt = duty_usd * exchange_rate
        vat_kzt = vat_usd * exchange_rate

        # Суммирование всех платежей
        total_kzt = duty_kzt + vat_kzt + CUSTOMS_FEES['брокер'] + CUSTOMS_FEES['декларация']
        # Добавление стоимости сертификата, если он нужен
        if needs_certificate:
            total_kzt += CUSTOMS_FEES['сертификат']

        return {
            'duty_kzt': duty_kzt,
            'vat_kzt': vat_kzt,
            'total_kzt': total_kzt,
            'customs_rate_percent': customs_rate_percent
        }
    except Exception as e:
        logger.error(f"Ошибка при расчете таможенных платежей: {e}", exc_info=True)
        return None

# --- 9. ВЗАИМОДЕЙСТВИЕ С GEMINI (КРОМЕ ИНИЦИАЛИЗАЦИИ) ---
# --------------------------------------------------------------------------------------------------

def get_tnved_code(product_name):
    """
    Получает 10-значный код ТН ВЭД для товара через специализированную модель Gemini.
    """
    if not customs_model:
        logger.warning("Модель ТНВЭД не инициализирована. Возвращен код по умолчанию.")
        return "3926909709" # Код для "прочих товаров"
    try:
        product_name_for_prompt = product_name if product_name else "общие товары"
        response = customs_model.generate_content(f"Код ТНВЭД для: '{product_name_for_prompt}'")
        code = response.text.strip()
        # Простая валидация формата ответа
        if re.match(r'^\d{10}$', code):
            logger.info(f"Для '{product_name_for_prompt}' получен код ТНВЭД: {code}")
            return code
        else:
            logger.warning(f"Gemini вернул некорректный код ТНВЭД: '{code}'. Используется код по умолчанию.")
            return "3926909709"
    except Exception as e:
        logger.error(f"Ошибка при получении кода ТН ВЭД: {e}")
        return "3926909709"

def check_certification_requirements(product_name):
    """
    Проверяет через Gemini, требуется ли сертификация для данного типа товара.
    """
    if not main_model: # Используем основную модель для простых вопросов
        return False
    try:
        prompt = f"Для товара '{product_name}' при импорте в Казахстан требуется сертификат соответствия ТР ТС? Ответь только одно слово: ДА или НЕТ."
        response = main_model.generate_content(prompt)
        answer = response.text.strip().upper()
        logger.info(f"Проверка сертификации для '{product_name}': Ответ Gemini - '{answer}'")
        return "ДА" in answer
    except Exception as e:
        logger.error(f"Ошибка при проверке необходимости сертификации: {e}")
        return False # По умолчанию считаем, что не требуется, чтобы не завышать стоимость

def get_gemini_response(user_message, context=""):
    """
    Получает ответ на отвлеченный вопрос пользователя через основную модель Gemini.
    """
    if not main_model:
        return "Извините, я сейчас не могу ответить на общие вопросы. Давайте вернемся к расчету доставки."
    try:
        prompt = f"Предыдущий контекст диалога: {context}\n\nСообщение пользователя: {user_message}"
        response = main_model.generate_content(prompt)
        return response.text
    except Exception as e:
        logger.error(f"Ошибка при генерации ответа Gemini: {e}")
        return "К сожалению, произошла ошибка. Давайте попробуем еще раз."


# --- 10. ФУНКЦИИ ФОРМАТИРОВАНИЯ ОТВЕТОВ БОТА ---
# --------------------------------------------------------------------------------------------------
# Эти функции собирают рассчитанные данные и преобразуют их в красивые,
# понятные для клиента сообщения.

def get_cargo_calculation_response(delivery_data, delivery_cost, exchange_rate):
    """
    Формирует красивый и подробный ответ с расчетом для КАРГО.
    """
    density_info = f"📦 **Плотность груза:** {delivery_cost['density']:.1f} кг/м³"
    t1_basis_info = f"💡 *Тариф Т1 ({delivery_cost['t1_description']}) рассчитан за {'**объем (м³)**, так как это выгоднее для легкого груза' if delivery_cost['t1_unit'] == 'm3' else '**вес (кг)**'}*"
    
    cost_t1_with_service = delivery_cost['t1_cost'] * 1.20
    cost_t1_t2_with_service = (delivery_cost['t1_cost'] + delivery_cost['t2_cost']) * 1.20
    
    return (
        f"📊 **Расчет для КАРГО доставки:**\n\n"
        f"✅ **Товар:** {delivery_data['weight']} кг «{delivery_data['product_type']}»\n"
        f"✅ **Объем:** {delivery_data.get('volume', 'N/A'):.2f} м³ {f'({delivery_data.get(\"dimensions_str\", \"\")})' if delivery_data.get('dimensions_str') else ''}\n"
        f"✅ **Город:** {delivery_data['city'].capitalize()}\n"
        f"✅ {density_info}\n\n"
        f"*{t1_basis_info}*\n\n"
        f"--- \n"
        f"🏷️ **Выберите вариант доставки:**\n\n"
        f"**🚚 ВАРИАНТ 1: ДОСТАВКА ДО АЛМАТЫ (Т1)**\n"
        f"• **Описание:** Доставка до нашего склада в г. Алматы (для самовывоза).\n"
        f"• **Стоимость доставки:** {delivery_cost['t1_cost']:,.0f} ₸\n"
        f"• **Сервисный сбор (20%):** {delivery_cost['t1_cost'] * 0.20:,.0f} ₸\n"
        f"💰 **ИТОГО: {cost_t1_with_service:,.0f} ₸**\n\n"
        f"**🏠 ВАРИАНТ 2: ДОСТАВКА ДО ДВЕРИ (Т1+Т2)**\n"
        f"• **Описание:** Доставка до вашего адреса в г. {delivery_data['city'].capitalize()}.\n"
        f"• **Стоимость доставки:** {(delivery_cost['t1_cost'] + delivery_cost['t2_cost']):,.0f} ₸\n"
        f"• **Сервисный сбор (20%):** {(delivery_cost['t1_cost'] + delivery_cost['t2_cost']) * 0.20:,.0f} ₸\n"
        f"💰 **ИТОГО: {cost_t1_t2_with_service:,.0f} ₸**\n\n"
        f"--- \n"
        f"📈 *Расчет выполнен по курсу НБ РК на сегодня: {exchange_rate:.2f} ₸ за 1 USD.*\n\n"
        f"💡 **Напишите `1` или `2`, чтобы выбрать подходящий вариант.**"
    )

def get_customs_full_calculation(delivery_data, customs_data, tnved_code, exchange_rate):
    """
    Формирует ответ с полным расчетом для ИНВОЙС, включая таможенные платежи.
    """
    delivery_cost = calculate_quick_cost(delivery_data['weight'], delivery_data['volume'], delivery_data['product_type'], delivery_data['city'], exchange_rate)
    if not delivery_cost or delivery_cost.get('error'):
        return "❌ Ошибка расчета стоимости доставки. " + (delivery_cost.get('error') or "Пожалуйста, проверьте введенные данные.")
    
    needs_certification = check_certification_requirements(delivery_data['product_type'])
    customs_cost = calculate_customs_cost(customs_data['invoice_value'], delivery_data['product_type'], delivery_data['weight'], exchange_rate, needs_certification)
    if not customs_cost:
        return "❌ Ошибка расчета таможенных платежей."
    
    t1_total = delivery_cost['t1_cost'] * 1.20 + customs_cost['total_kzt']
    t2_total = (delivery_cost['t1_cost'] + delivery_cost['t2_cost']) * 1.20 + customs_cost['total_kzt']
    
    return (
        f"📊 **Расчет для ИНВОЙС:**\n\n"
        f"✅ **Товар:** {delivery_data['weight']} кг «{delivery_data['product_type']}» в г. {delivery_data['city'].capitalize()}\n"
        f"✅ **Таможенная стоимость:** {customs_data['invoice_value']:,.2f} USD\n"
        f"✅ **Код ТНВЭД:** {tnved_code}\n\n"
        f"--- \n"
        f"🏷️ **Выберите вариант доставки:**\n\n"
        f"**🚚 ВАРИАНТ 1: ДОСТАВКА ДО АЛМАТЫ (Т1)**\n"
        f"• **Описание:** Полная стоимость, включая доставку до Алматы и все таможенные платежи.\n"
        f"💰 **ИТОГО ПОД КЛЮЧ: {t1_total:,.0f} ₸**\n\n"
        f"**🏠 ВАРИАНТ 2: ДОСТАВКА ДО ДВЕРИ (Т1+Т2)**\n"
        f"• **Описание:** Полная стоимость, включая доставку до вашего адреса и все таможенные платежи.\n"
        f"💰 **ИТОГО ПОД КЛЮЧ: {t2_total:,.0f} ₸**\n\n"
        f"--- \n"
        f"📄 **Сертификация:** {'требуется' if needs_certification else 'не требуется'}\n"
        f"📈 *Расчет выполнен по курсу НБ РК на сегодня: {exchange_rate:.2f} ₸ за 1 USD.*\n\n"
        f"💡 **Напишите `1` или `2` чтобы выбрать вариант.**"
    )

def show_final_calculation(delivery_data, customs_data, delivery_option, exchange_rate):
    """
    Показывает итоговый расчет после того, как пользователь выбрал вариант доставки.
    """
    delivery_cost = calculate_quick_cost(delivery_data['weight'], delivery_data['volume'], delivery_data['product_type'], delivery_data['city'], exchange_rate)
    if not delivery_cost or delivery_cost.get('error'): return "❌ Ошибка итогового расчета."

    if delivery_data['delivery_type'] == 'CARGO':
        total_cost = delivery_cost['t1_cost'] * 1.20 if delivery_option == "самовывоз" else (delivery_cost['t1_cost'] + delivery_cost['t2_cost']) * 1.20
    else: # INVOICE
        customs_cost_data = calculate_customs_cost(customs_data['invoice_value'], delivery_data['product_type'], delivery_data['weight'], exchange_rate)
        total_delivery = delivery_cost['t1_cost'] * 1.20 if delivery_option == "самовывоз" else (delivery_cost['t1_cost'] + delivery_cost['t2_cost']) * 1.20
        total_cost = total_delivery + customs_cost_data['total_kzt']

    return (
        f"✅ **Отлично! Выбран вариант: ДОСТАВКА ДО {'ДВЕРИ' if delivery_option == 'до двери' else 'АЛМАТЫ (самовывоз)'}**\n\n"
        f"💰 **Итоговая стоимость: {total_cost:,.0f} ₸**\n"
        f"⏱️ Примерный срок доставки: 12-15 дней\n\n"
        f"💎 **Если вас все устраивает, давайте оформим заявку!**\n"
        f"📝 Для этого, пожалуйста, напишите ваше **имя и номер телефона** (например: `Айдос, 87051234567`)"
    )

# --- 11. ПРОЧИЕ ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---
# --------------------------------------------------------------------------------------------------

def get_missing_data(delivery_data, customs_data, delivery_type):
    """
    Проверяет, каких данных не хватает для выполнения расчета, и возвращает их список.
    """
    missing = []
    if not validate_weight_volume(delivery_data.get('weight')):
        missing.append("вес груза (в кг)")
    if not validate_weight_volume(delivery_data.get('volume')):
        missing.append("объем груза (в м³) или габариты (Д×Ш×В в см)")
    if not delivery_data.get('product_type'):
        missing.append("тип товара (например: одежда, электроника)")
    if not delivery_data.get('city'):
        missing.append("город доставки в Казахстане")

    if delivery_type == 'INVOICE':
        if not (customs_data.get('invoice_value') and customs_data.get('invoice_value') > 0):
            missing.append("стоимость товаров в USD")
        # ТНВЭД код не обязателен, т.к. может быть определен автоматически
        # if not customs_data.get('tnved_code'):
        #     missing.append("код ТНВЭД")
    return missing

def save_application(details):
    """
    Сохраняет детали оформленной заявки в текстовый файл "applications.txt".
    """
    try:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"Новая заявка: {timestamp}\n{details}\n"
        with open("applications.txt", "a", encoding="utf-8") as f:
            f.write("="*60 + "\n" + log_entry + "="*60 + "\n\n")
        logger.info(f"Заявка успешно сохранена: {details.splitlines()[0]}")
    except Exception as e:
        logger.error(f"Ошибка при сохранении заявки в файл: {e}")

# --- 12. ГЛАВНАЯ ЛОГИКА ПРИЛОЖЕНИЯ (FLASK ROUTES) ---
# --------------------------------------------------------------------------------------------------
# Это сердце приложения, где обрабатываются все запросы от пользователя.

@app.route('/', methods=['GET'])
def index():
    """
    Рендерит главную страницу чата и инициализирует сессию для нового пользователя.
    """
    # Очистка и установка значений по умолчанию для сессии
    session.clear()
    session['delivery_data'] = {}
    session['customs_data'] = {}
    session['chat_history'] = []
    # Вводим состояния: initial, gathering, calculated, ordering
    session['state'] = 'initial'
    logger.info(f"Новая сессия {session.sid} создана.")

    # Инициализация моделей, если они еще не загружены
    if main_model is None:
        initialize_models()

    return render_template('index.html')


@app.route('/chat', methods=['POST'])
def chat():
    """
    Основной обработчик сообщений пользователя. Управляет состоянием диалога.
    """
    try:
        user_message = request.json.get('message', '').strip()
        if not user_message:
            return jsonify({"response": "Пожалуйста, введите ваше сообщение."})

        # Загрузка данных из сессии
        delivery_data = session.get('delivery_data', {})
        customs_data = session.get('customs_data', {})
        chat_history = session.get('chat_history', [])
        state = session.get('state', 'initial')

        chat_history.append(f"Клиент: {user_message}")
        logger.info(f"Сессия {session.sid} | Состояние: {state} | Сообщение: '{user_message}'")

        # --- Обработка команды сброса в любом состоянии ---
        if user_message.lower() in ['/start', 'сброс', 'старт', 'начать заново', 'новый расчет']:
            session.clear()
            logger.info(f"Сессия {session.sid} сброшена пользователем.")
            response_text = ("🚚 **Диалог сброшен. Начнем заново!**\n\n"
                           "Я помогу вам рассчитать стоимость доставки из Китая в Казахстан.\n\n"
                           "💡 **Для расчета укажите:**\n"
                           "• Вес груза (например: `50 кг`)\n"
                           "• Объем (м³) или габариты (`120х80х60 см`)\n"
                           "• Тип товара (например: `одежда`)\n"
                           "• Город доставки в Казахстане")
            session['state'] = 'initial'
            return jsonify({"response": response_text})

        # --- Логика в зависимости от состояния диалога ---

        # Состояние 1: Ожидание выбора варианта после расчета
        if state == 'calculated':
            if is_delivery_choice(user_message):
                delivery_option = parse_delivery_choice(user_message)
                delivery_data['delivery_option'] = delivery_option
                session['delivery_data'] = delivery_data
                current_rate = session.get('current_exchange_rate', 450.0)
                response = show_final_calculation(delivery_data, customs_data, delivery_option, current_rate)
                state = 'ordering' # Переход в состояние оформления
            else:
                response = get_gemini_response(user_message, "Клиент задает отвлеченный вопрос. Ответь кратко и вежливо, а затем настойчиво напомни выбрать вариант доставки, написав '1' или '2'.")
        
        # Состояние 2: Ожидание контактных данных для оформления
        elif state == 'ordering':
            name, phone = extract_contact_info(user_message)
            if name and phone:
                app_details = (
                    f"Тип доставки: {delivery_data.get('delivery_type', 'N/A')}\n"
                    f"Вес: {delivery_data.get('weight')} кг\n"
                    f"Объем: {delivery_data.get('volume'):.2f} м³\n"
                    f"Товар: {delivery_data.get('product_type')}\n"
                    f"Город: {delivery_data.get('city')}\n"
                    f"Выбранный вариант: {delivery_data.get('delivery_option')}\n"
                    f"Имя клиента: {name}\n"
                    f"Телефон клиента: {phone}\n"
                )
                if delivery_data.get('delivery_type') == 'INVOICE':
                    app_details += (f"Стоимость инвойса: {customs_data.get('invoice_value')} USD\n"
                                    f"Код ТНВЭД: {customs_data.get('tnved_code', 'не указан')}\n")
                save_application(app_details)
                response = f"✅ **Заявка успешно оформлена!**\n\n{name}, наш менеджер свяжется с вами по номеру `{phone}` в ближайшее рабочее время для подтверждения деталей.\n\nСпасибо, что выбрали PostPro! 🚚\n\n🔄 *Для нового расчета напишите «старт»*"
                state = 'finished' # Диалог завершен
            else:
                response = "❌ **Не удалось распознать контакты.**\n\nПожалуйста, введите ваше **имя и номер телефона** в одном сообщении. Например: `Мария, 77071234567`"
        
        # Состояние 3: Сбор данных и первичная обработка
        else: # state == 'initial' or 'gathering'
            extracted_delivery = extract_delivery_info(user_message)
            delivery_data.update(extracted_delivery)
            
            extracted_customs_val, extracted_tnved = extract_customs_info(user_message)
            if extracted_customs_val: customs_data['invoice_value'] = extracted_customs_val
            if extracted_tnved: customs_data['tnved_code'] = extracted_tnved
            
            if not delivery_data.get('delivery_type'):
                delivery_data['delivery_type'] = 'INVOICE' if customs_data.get('invoice_value') or 'инвойс' in user_message.lower() else 'CARGO'
            
            missing_data = get_missing_data(delivery_data, customs_data, delivery_data['delivery_type'])
            
            if missing_data:
                response = f"📋 Для продолжения расчета, пожалуйста, укажите: **{', '.join(missing_data)}**"
                state = 'gathering'
            else:
                # Все данные собраны, выполняем расчет
                current_rate = get_current_exchange_rate()
                session['current_exchange_rate'] = current_rate
                
                if delivery_data['delivery_type'] == 'CARGO':
                    delivery_cost = calculate_quick_cost(delivery_data['weight'], delivery_data['volume'], delivery_data['product_type'], delivery_data['city'], current_rate)
                    if delivery_cost and not delivery_cost.get('error'):
                        response = get_cargo_calculation_response(delivery_data, delivery_cost, current_rate)
                        state = 'calculated'
                    else:
                        response = "❌ Ошибка расчета. " + (delivery_cost.get('error') or "Пожалуйста, проверьте введенные данные и попробуйте снова.")
                
                else: # INVOICE
                    if not customs_data.get('tnved_code'):
                         if doesnt_know_tnved(user_message):
                            tnved_code = get_tnved_code(delivery_data['product_type'])
                            customs_data['tnved_code'] = tnved_code
                            response = get_customs_full_calculation(delivery_data, customs_data, tnved_code, current_rate)
                            state = 'calculated'
                         else:
                            response = "📋 **Для расчета ИНВОЙСА укажите код ТНВЭД.**\n\nЕсли вы не знаете код, просто напишите `не знаю`, и я определю его автоматически."
                            state = 'gathering' # Остаемся в состоянии сбора данных
                    else:
                        response = get_customs_full_calculation(delivery_data, customs_data, customs_data['tnved_code'], current_rate)
                        state = 'calculated'

        # Сохранение состояния и истории в сессию
        session['delivery_data'] = delivery_data
        session['customs_data'] = customs_data
        session['chat_history'] = chat_history
        session['state'] = state
        
        chat_history.append(f"Ассистент: {response}")
        logger.info(f"Сессия {session.sid} | Ответ: '{response[:150].replace('\n', ' ')}...'")
        
        return jsonify({"response": response})

    except Exception as e:
        logger.critical(f"КРИТИЧЕСКАЯ ОШИБКА в /chat: {e}", exc_info=True)
        return jsonify({"response": "Произошла серьезная внутренняя ошибка. Пожалуйста, попробуйте обновить страницу и начать заново, написав «старт»."})


@app.route('/clear', methods=['POST'])
def clear_chat():
    """
    Обработчик для кнопки сброса сессии на стороне клиента.
    """
    session.clear()
    logger.info(f"Сессия {session.sid} очищена клиентом.")
    return jsonify({"status": "success"})


# --- 13. ТОЧКА ВХОДА ДЛЯ ЗАПУСКА ПРИЛОЖЕНИЯ ---
# --------------------------------------------------------------------------------------------------

if __name__ == '__main__':
    """
    Точка входа в приложение. Инициализирует модели и запускает веб-сервер Flask.
    Сервер будет доступен по всем сетевым интерфейсам на порту 5000.
    """
    if initialize_models():
        try:
            hostname = socket.gethostname()
            local_ip = socket.gethostbyname(hostname)
            logger.info("=" * 60)
            logger.info("           POSTPRO CHATBOT УСПЕШНО ЗАПУЩЕН")
            logger.info("           ВЕРСИЯ: 3.0.0 (С ДИНАМИЧЕСКИМ КУРСОМ)")
            logger.info("=" * 60)
            logger.info(f"  -> Локальный доступ: http://localhost:5000")
            logger.info(f"  -> Сетевой доступ:   http://{local_ip}:5000")
            logger.info("-" * 60)
            # debug=True используется для разработки, для продакшена следует установить в False
            app.run(host='0.0.0.0', port=5000, debug=True)
        except Exception as e:
            logger.error(f"Не удалось запустить Flask сервер: {e}")
    else:
        logger.error("!!! ЗАПУСК НЕВОЗМОЖЕН: Не удалось инициализировать модели Gemini.")
# --- КОНЕЦ ФАЙЛА ---
